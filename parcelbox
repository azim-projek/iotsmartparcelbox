// =====================================================================
// üß† Smart Parcel Box - ESP32 + Keypad + Servo + Ultrasonic + Telegram
// ---------------------------------------------------------------------
// Features:
// - Detects parcel using ultrasonic sensor
// - Opens/closes door with two MG996R servos
// - Unlocks with keypad password
// - Sends notifications & controls via Telegram bot
// - Auto Wi-Fi reconnection
// =====================================================================

#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <UniversalTelegramBot.h>
#include <ESP32Servo.h>
#include <Keypad.h>

// === WiFi & Telegram Settings ===
const char* WIFI_SSID = "realme GT NEO 3";  // WiFi name
const char* WIFI_PASS = "miskinsangatke";   // WiFi password
#define BOT_TOKEN "8259717729:AAGfa-sK4DOhWsJcyrXl2sO_QODNMwDc6wI"  // Telegram bot token
#define CHAT_ID   "1034103142"  // Your Telegram user chat ID

WiFiClientSecure client;                 // Secure client for HTTPS connection
UniversalTelegramBot bot(BOT_TOKEN, client);  // Initialize Telegram bot

// === Ultrasonic Sensor Pins ===
#define TRIG_PIN 16   // Trig pin of ultrasonic sensor
#define ECHO_PIN 34   // Echo pin of ultrasonic sensor

// === Servo Pins ===
#define SERVO_DROP 17   // Top servo for dropping parcel
#define SERVO_DOOR 18   // Bottom servo for main door

// === Door Lock Pin (relay or transistor) ===
#define LOCK_PIN 19     // Controls the solenoid door lock

Servo dropServo;        // Servo object for drop door
Servo doorServo;        // Servo object for main door

// === Keypad Setup ===
const byte ROWS = 4;  // 4 rows
const byte COLS = 4;  // 4 columns
char keys[ROWS][COLS] = {  // Define keypad layout
  {'1','2','3','A'},
  {'4','5','6','B'},
  {'7','8','9','C'},
  {'*','0','#','D'}
};

// Define which ESP32 pins connect to keypad
byte rowPins[ROWS] = {27, 14, 12, 13};
byte colPins[COLS] = {32, 33, 25, 26};
Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

// === Variables ===
long duration;               // Time for ultrasonic echo
int distance;                // Calculated distance in cm
const int threshold = 15;    // Distance threshold to detect parcel
bool parcelDetected = false; // Flag to prevent duplicate detection

String correctPassword = "1234";  // Default password
String enteredPassword = "";      // Stores user keypad input
unsigned long lastCheckTime = 0;  // Timer for Telegram message checking
const unsigned long TELEGRAM_CHECK_INTERVAL = 2000; // Check every 2s

// === Ultrasonic Distance Function ===
int readUltrasonic() {
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);

  // Measure pulse duration
  duration = pulseIn(ECHO_PIN, HIGH, 30000);
  return duration * 0.034 / 2; // Convert to cm
}

// === Servo Movement Function ===
void moveServo(Servo &servo, int angle, int delayTime = 1000) {
  servo.write(angle);
  delay(delayTime);
}

// === Control Both Servos ===
void moveBothServos() {
  dropServo.attach(SERVO_DROP);
  doorServo.attach(SERVO_DOOR);

  // Step 1: Rotate clockwise to open
  dropServo.write(0);
  doorServo.write(0);
  delay(3000);

  // Step 2: Middle position (half rotation)
  dropServo.write(90);
  doorServo.write(90);
  delay(3000);

  // Step 3: Rotate to 180¬∞ to close
  dropServo.write(180);
  doorServo.write(180);
  delay(3000);

  // Step 4: Stop & detach to reduce noise
  dropServo.detach();
  doorServo.detach();
}

// === Wi-Fi Auto Reconnect ===
void ensureWiFiConnected() {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("‚ö†Ô∏è WiFi lost. Reconnecting...");
    WiFi.disconnect();
    WiFi.begin(WIFI_SSID, WIFI_PASS);
    unsigned long startAttemptTime = millis();

    // Try for 10 seconds
    while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 10000) {
      delay(500);
      Serial.print(".");
    }

    // Report result
    if (WiFi.status() == WL_CONNECTED) {
      Serial.println("\n‚úÖ WiFi Reconnected!");
      bot.sendMessage(CHAT_ID, "üì∂ WiFi reconnected successfully!", "");
    } else {
      Serial.println("\n‚ùå Failed to reconnect.");
    }
  }
}

// === Telegram Commands ===
void handleNewMessages(int numNewMessages) {
  for (int i = 0; i < numNewMessages; i++) {
    String chat_id = String(bot.messages[i].chat_id);
    String text = bot.messages[i].text;
    if (chat_id != CHAT_ID) continue; // Ignore messages from others

    // /setpass command to change password
    if (text.startsWith("/setpass ")) {
      String newPass = text.substring(9);
      if (newPass.length() >= 4 && newPass.length() <= 8) {
        correctPassword = newPass;
        bot.sendMessage(CHAT_ID, "üîë Password updated to: " + correctPassword, "");
      } else {
        bot.sendMessage(CHAT_ID, "‚ùå Invalid password length (4-8 digits).", "");
      }
    } 
    // /getpass command to show current password
    else if (text == "/getpass") {
      bot.sendMessage(CHAT_ID, "üîê Current password: " + correctPassword, "");
    } 
    // /help command to show all commands
    else if (text == "/help") {
      bot.sendMessage(CHAT_ID,
        "üìã *Smart Parcel Box Commands:*\n"
        "/setpass <newpass> - Change password\n"
        "/getpass - Show current password\n"
        "/help - Show command list",
        "Markdown");
    }
  }
}

// === Setup Function ===
void setup() {
  Serial.begin(115200);

  // Connect to Wi-Fi
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  WiFi.setAutoReconnect(true);
  WiFi.persistent(true);

  Serial.print("Connecting to WiFi");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\n‚úÖ WiFi Connected");
  client.setInsecure(); // Disable SSL check

  // Pin setup
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
  pinMode(LOCK_PIN, OUTPUT);
  digitalWrite(LOCK_PIN, LOW); // Lock is off initially

  // Initialize servo positions (not attached)
  dropServo.write(0);
  doorServo.write(0);

  // Telegram startup message
  bot.sendMessage(CHAT_ID, "üì¶ Smart Parcel Box System Online!\nUse /help for commands.", "");
}

// === Main Loop ===
void loop() {
  ensureWiFiConnected(); // Keep Wi-Fi alive

  // --- Check Ultrasonic Sensor ---
  distance = readUltrasonic();
  Serial.print("Distance: ");
  Serial.print(distance);
  Serial.println(" cm");

  // Detect new parcel
  if (distance > 0 && distance < threshold && !parcelDetected) {
    parcelDetected = true;
    bot.sendMessage(CHAT_ID, "üì¶ Parcel detected! Dropping into storage...", "");

    moveBothServos(); // Open & close sequence

    bot.sendMessage(CHAT_ID, "‚úÖ Parcel safely stored!", "");
  }

  // Reset detection when parcel removed
  if (distance > (threshold + 5) && parcelDetected) {
    parcelDetected = false;
    Serial.println("üîÅ Ready for next parcel");
  }

  // --- Keypad Password Entry ---
  char key = keypad.getKey();
  if (key) {
    Serial.print("Key pressed: ");
    Serial.println(key);

    if (key == '#') {  // Confirm entry
      enteredPassword.trim();
      correctPassword.trim();

      if (enteredPassword == correctPassword) {
        Serial.println("‚úÖ Correct password!");
        bot.sendMessage(CHAT_ID, "üîì Correct password! Unlocking door...", "");

        digitalWrite(LOCK_PIN, HIGH); // Unlock door
        delay(5000);                  // Keep unlocked for 5s
        digitalWrite(LOCK_PIN, LOW);  // Lock again
        bot.sendMessage(CHAT_ID, "üì≠ Door locked again.", "");
      } else {
        Serial.println("‚ùå Wrong password!");
        bot.sendMessage(CHAT_ID, "‚ùå Wrong password!", "");
      }

      enteredPassword = ""; // Clear after entry
    } 
    else if (key == '*') {  // Clear input
      enteredPassword = "";
      Serial.println("Password cleared.");
    } 
    else {  // Add character to password
      enteredPassword += key;
      Serial.print("Entered so far: ");
      Serial.println(enteredPassword);
    }
  }

  // --- Telegram Message Check ---
  if (millis() - lastCheckTime > TELEGRAM_CHECK_INTERVAL) {
    int numNewMessages = bot.getUpdates(bot.last_message_received + 1);
    while (numNewMessages) {
      handleNewMessages(numNewMessages);
      numNewMessages = bot.getUpdates(bot.last_message_received + 1);
    }
    lastCheckTime = millis();
  }

  delay(300); // Prevent flooding
}
